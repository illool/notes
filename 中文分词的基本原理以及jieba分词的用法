结巴分词是国内程序员用Python开发的一个中文分词模块，可能是最好的Python中文分词组件？
中文分词的原理

1、中文分词(Chinese Word Segmentation) 指的是将一个汉字序列切分成一个一个单独的词。分词就是将连续的字序列按照一定的规范重新组合成词序列的过程
2、现有的分词算法可分为三大类：基于字符串匹配的分词方法、基于理解的分词方法和基于统计的分词方法
    基于字符串匹配的分词方法：这种方法又叫做机械分词方法，它是按照一定的策略将待分析的汉字串与一个“充分大的”机器词典中的词条进行配，若在词典中找到某个字符串，则匹配成功（识别出一个词）
    1）正向最大匹配法（由左到右的方向）
    2）逆向最大匹配法（由右到左的方向）:
    3）最少切分（使每一句中切出的词数最小）
    4）双向最大匹配法（进行由左到右、由右到左两次扫描）
    基于理解的分词方法：这种分词方法是通过让计算机模拟人对句子的理解，达到识别词的效果。其基本思想就是在分词的同时进行句法、语义分析，利用句法信息和语义信息来处理歧义现象。它通常包括三个部分：分词子系统、句法语义子系统、总控部分。在总控部分的协调下，分词子系统可以获得有关词、句子等的句法和语义信息来对分词歧义进行判断，即它模拟了人对句子的理解过程。这种分词方法需要使用大量的语言知识和信息。由于汉语语言知识的笼统、复杂性，难以将各种语言信息组织成机器可直接读取的形式，因此目前基于理解的分词系统还处在试验阶段。
    基于统计的分词方法：给出大量已经分词的文本，利用统计机器学习模型学习词语切分的规律（称为训练），从而实现对未知文本的切分。例如最大概率分词方法和最大熵分词方法等。随着大规模语料库的建立，统计机器学习方法的研究和发展，基于统计的中文分词方法渐渐成为了主流方法。
    主要统计模型：N元文法模型（N-gram），隐马尔可夫模型（Hidden Markov Model ，HMM），最大熵模型（ME），条件随机场模型（Conditional Random Fields，CRF）等。

Feature

    支持三种分词模式
    1 精确模式，试图将句子最精确地切开，适合文本分析；
    2 全模式，把句子中所有的可以成词的词语都扫描出来, 速度非常快，但是不能解决歧义；
    3 搜索引擎模式，在精确模式的基础上，对长词再次切分，提高召回率，适合用于搜索引擎分词。
    支持繁体分词
    支持自定义词典

基本用法示例
1、分词

# -*- coding: utf-8 -*-

import jieba
import jieba.posseg as pseg
import jieba.analyse

str1 = "我来到北京清华大学"
str2 = 'python的正则表达式是好用的'
str3 = "小明硕士毕业于中国科学院计算所，后在日本京都大学深造"

seg_list = jieba.cut(str1,cut_all = True)   ##全模式
result = pseg.cut(str1)                     ##词性标注，标注句子分词后每个词的词性
result2 = jieba.cut(str2)                   ##默认是精准模式
result3 =  jieba.analyse.extract_tags(str1,2)
##关键词提取，参数setence对应str1为待提取的文本,topK对应2为返回几个TF/IDF权重最大的关键词，默认值为20
result4 = jieba.cut_for_search(str3)        ##搜索引擎模式

print " /".join(seg_list)
>>>我 /来到 /北京 /清华 /清华大学 /华大 /大学


for w in  result:
    print w.word, "/", w.flag, ", ",
>>>我 / r ,  来到 / v ,  北京 / ns ,  清华大学 / nt ,  



for t in result2:
    print t,
>>>python 的 正则表达式 是 好 用 的




for s in result3:
    print s
>>>清华大学
    来到


print " ,".join(result4)
>>>小明 ,硕士 ,毕业 ,于 ,中国 ,科学 ,学院 ,科学院 ,中国科学院 ,计算 ,计算所 ,， ,后 ,在 ,日本 ,京都 ,大学 ,日本京都大学 ,深造


2、返回词所在位置

import jieba

test_sent = u"永和服装饰品有限公司"
result = jieba.tokenize(test_sent) ##Tokenize：返回词语在原文的起始位置
for tk in result:
    print "word %s\t\t start: %d \t\t end:%d" % (tk[0],tk[1],tk[2])
    print tk
>>>
>word 永和         start: 0        end:2
(u'\u6c38\u548c', 0, 2)
word 服装      start: 2        end:4
(u'\u670d\u88c5', 2, 4)
word 饰品      start: 4        end:6
(u'\u9970\u54c1', 4, 6)
word 有限公司        start: 6        end:10
(u'\u6709\u9650\u516c\u53f8', 6, 10)

3、自定义词典

# -*- coding: utf-8 -*-
import sys
import jieba
jieba.load_userdict('userdict.txt')

test_sent = "大连美容美发学校中君意是你值得信赖的选择"
test_sent2 = '江州市长江大桥参加了长江大桥的通车仪式'


print ", ".join(jieba.cut(test_sent))
>>>大连, 美容美发, 学校, 中, 君意, 是, 你, 值得, 信赖, 的, 选择


print ", ".join(jieba.cut(test_sent2))
>>>江州, 市长, 江大桥, 参加, 了, 长江大桥, 的, 通车, 仪式


自定义词典的格式：一个词占一行；每一行分三部分，一部分为词语，另一部分为词频，最后为词性（可省略），用空格隔开
其中user_dict.txt的内容是：
云计算 5
李小福 2 nr
创新办 3 i
easy_install 3 eng
好用 300
韩玉赏鉴 3 nz
八一双鹿 3 nz
台中
凱特琳 nz
Edu Trust认证 2000
君意 3
江大桥 20000

jieba分词的基本原理

第一条：基于Trie树结构实现高效的词图扫描，生成句子中汉字所有可能成词情况所构成的有向无环图（DAG)

这个看上面的trie树的python实现， 结巴分词自带了一个叫做dict.txt的词典, 里面有2万多条词, 包含了词条出现的次数(这个次数是于作者自己基于人民日报语料等资源训练得出来的)和词性. 这个第一条的trie树结构的词图扫描, 说的就是把这2万多条词语, 放到一个trie树中, 而trie树是有名的前缀树, 也就是说一个词语的前面几个字一样, 就表示他们具有相同的前缀, 就可以使用trie树来存储, 具有查找速度快的优势.

聪明的人可能会想到把 dict.txt中所有的词汇全部删掉, 然后再试试结巴能不能分词, 结果会发现, 结巴依然能够分词, 不过分出来的词, 大部分的长度为2.这个就是第三条, 基于HMM来预测分词了.

接着说DAG有向无环图, 就是后一句的 生成句子中汉字所有可能成词情况所构成的有向无环图, 这个是说的, 给定一个句子, 要你分词, 也就是给定一个 待分词的句子, 对这个句子进行生成有向无环图. 如果对有向无环图理解不了可以百度或者google搜索, 也可以看这篇 http://book.51cto.com/art/201106/269048.htm 比较形象的用图来表示了一个待分词句子的切分情况.

作者是怎么切分的呢? 1. 根据dict.txt生成trie树, 2, 对待分词句子, 根据dict.txt生成的trie树, 生成DAG, 实际上通俗的说, 就是对待分词句子, 根据给定的词典进行查词典操作, 生成几种可能的句子切分. dag是啥玩意?记录了啥呢? 作者的源码中记录的是句子中某个词的开始位置, 从0到n-1(n为句子的长度), 每个开始位置作为字典的键, value是个list, 其中保存了可能的词语的结束位置(通过查字典得到词, 开始位置+词语的长度得到结束位置)

例如:{0:[1,2,3]} 这样一个简单的DAG, 就是表示0位置开始, 在1,2,3位置都是词, 就是说0~1, 0~2,0~3这三个起始位置之间的字符, 在dict.txt中是词语.

第二条:采用了动态规划查找最大概率路径, 找出基于词频的最大切分组合

关于动态规划查找最大概率路径, 这个在一些大学课程中讲的很多了, 不熟悉的或者忘记了的翻翻百度就行了. 上面给的那个在线书籍的链接中也说的很明白了, 我这里就说说作者的代码:

作者的代码中讲字典在生成trie树的同时, 也把每个词的出现次数转换为了频率. 关于频率和概率, 这里在啰嗦几句: 按照定义, 频率其实也是一个0~1之间的小数, 是 事件出现的次数/实验中的总次数, 因此在试验次数足够大的情况下, 频率约等于概率, 或者说频率的极限就是概率. 不过通常人们混淆的是频率和次数, 经常把频率等同于事件出现的次数, 比如这里就是某个词语出现的次数, 所以, 频率在引起混淆的时候, 对中国人来说, 还是先理解为出现次数, 然后理解发现有问题, 就理解为出现次数/总数这个比率吧.

动态规划中, 先查找待分词句子中已经切分好的词语, 对该词语查找该词语出现的频率(次数/总数), 如果没有该词(既然是基于词典查找, 应该是有的), 就把词典中出现频率最小的那个词语的频率作为该词的频率, 也就是说P(某词语)=FREQ.get(‘某词语’,min_freq), 然后根据动态规划查找最大概率路径的方法, 对句子从右往左反向计算最大概率(一些教科书上可能是从左往右, 这里反向是因为汉语句子的重心经常落在后面, 就是落在右边, 因为通常情况下形容词太多, 后面的才是主干, 因此, 从右往左计算, 正确率要高于从左往右计算, 这个类似于逆向最大匹配), P(NodeN)=1.0, P(NodeN-1)=P(NodeN)*Max(P(倒数第一个词))…依次类推, 最后得到最大概率路径, 得到最大概率的切分组合.

第三条, 对于未登录词，采用了基于汉字成词能力的HMM模型，使用了Viterbi算法

未登录词, 作者说的是什么意思? 其实就是词典 dict.txt 中没有记录的词. 上面说了, 把dict.txt中的所有词语都删除了, 结巴分词一样可以分词, 就是说的这个.

怎么做到的? 这个就基于作者采用的HMM模型了, 中文词汇按照BEMS四个状态来标记, B是开始begin位置, E是end, 是结束位置, M是middle, 是中间位置, S是singgle, 单独成词的位置, 没有前, 也没有后. 也就是说, 他采用了状态为(B,E,M,S)这四种状态来标记中文词语, 比如北京可以标注为 BE, 即 北/B 京/E, 表示北是开始位置, 京是结束位置, 中华民族可以标注为BMME, 就是开始, 中间, 中间, 结束.

经过作者对大量语料的训练, 得到了finalseg目录下的三个文件(来自结巴项目的issues):

要统计的主要有三个概率表：

prob_trans.py
1)位置转换概率，即B（开头）,M（中间),E(结尾),S(独立成词）四种状态的转移概率；
{‘B’: {‘E’: 0.8518218565181658, ‘M’: 0.14817814348183422},
‘E’: {‘B’: 0.5544853051164425, ‘S’: 0.44551469488355755},
‘M’: {‘E’: 0.7164487459986911, ‘M’: 0.2835512540013088},
‘S’: {‘B’: 0.48617017333894563, ‘S’: 0.5138298266610544}}

P(E|B) = 0.851, P(M|B) = 0.149，说明当我们处于一个词的开头时，下一个字是结尾的概率
要远高于下一个字是中间字的概率，符合我们的直觉，因为二个字的词比多个字的词更常见。

prob_emit.py
2）位置到单字的发射概率，比如P(“和”|M)表示一个词的中间出现”和”这个字的概率；
prob_start.py
3) 词语以某种状态开头的概率，其实只有两种，要么是B，要么是S。这个就是起始向量, 就是HMM系统的最初模型状态
实际上, BEMS之间的转换有点类似于2元模型, 就是2个词之间的转移
二元模型考虑一个单词后出现另外一个单词的概率，是N元模型中的一种。
例如：一般来说，”中国”之后出现”北京”的概率大于”中国”之后出现”北海”的概率，也就是：中国北京 比 中国北海出现的概率大些, 更有可能是一个中文词语.

不过, 作者这里应该不是用的2元分词模型的, 这里的BEMS只提供了单个汉字之间的转换, 发射概率, 并没有提供粒度更大的, 基于词语的发射和转移概率, 当然, 也有可能我理解的不够深入.

给定一个 待分词的句子, 就是观察序列, 对HMM(BEMS)四种状态的模型来说, 就是为了找到一个最佳的BEMS序列, 这个就需要使用viterbi算法来得到这个最佳的隐藏状态序列, 具体的python版的viterbi算法请看维基百科:http://zh.wikipedia.org/wiki/%E7%BB%B4%E7%89%B9%E6%AF%94%E7%AE%97%E6%B3%95 维特比算法

通过作者之前训练得到的概率表和viterbi算法, 就可以得到一个概率最大的BEMS序列, 按照B打头, E结尾的方式, 对待分词的句子重新组合, 就得到了分词结果. 比如 对待分词的句子 ‘全世界都在学中国话’ 得到一个BEMS序列 [S,B,E,S,S,S,B,E,S] 这个序列只是举例, 不一定正确, 通过把连续的BE凑合到一起得到一个词, 单独的S放单, 就得到一个分词结果了: 上面的BE位置和句子中单个汉字的位置一一对应, 得到全/S 世界/BE 都/S 在/S 学/S 中国/BE 话/S 从而将句子切分为词语.

以上, 就是作者这三条介绍的全部理解和分析, 对于其中任何术语不理解, 请使用搜索引擎.

结巴分词的过程:

    加载字典, 生成trie树

    给定待分词的句子, 使用正则获取连续的 中文字符和英文字符, 切分成 短语列表, 对每个短语使用DAG(查字典)和动态规划, 得到最大概率路径, 对DAG中那些没有在字典中查到的字, 组合成一个新的片段短语, 使用HMM模型进行分词, 也就是作者说的识别新词, 即识别字典外的新词.

    使用python的yield 语法生成一个词语生成器, 逐词语返回. 当然, 我认为直接返回list, 效果也差不到哪里去.

参考文献

[1]: https://www.oschina.net/p/jieba?fromerr=ex7thahF
[2]:http://baike.baidu.com/linkurl=x2vBf5Kvw1vLU03kDD1qwgu8u3FqFXVRanaOeyF3p1GgWfKWxeaIoIbjmCsCe-_ls6Ay0KsUFlHdlckC_uJWcK
[3]: http://book.51cto.com/art/201106/269047.htm
[4]:http://blog.csdn.net/rav009/article/details/12196623
